import{x as P,r as c,y as k,z as O,A as g,B as z,C as B,u as R}from"./entry.06c95206.mjs";const A=s=>P(s)?s:c(s),M=()=>null;function j(...s){var p,h,m,v,D,_,w;const l=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(l);let[t,f,e={}]=s;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof f!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");e.server=(p=e.server)!=null?p:!0,e.default=(h=e.default)!=null?h:M,e.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),e.lazy=(v=(m=e.lazy)!=null?m:e.defer)!=null?v:!1,e.initialCache=(D=e.initialCache)!=null?D:!0;const a=k(),i=B();if(i&&!i._nuxtOnBeforeMountCbs){const o=i._nuxtOnBeforeMountCbs=[];i&&(O(()=>{o.forEach(r=>{r()}),o.splice(0,o.length)}),g(()=>o.splice(0,o.length)))}const u=()=>e.initialCache&&a.payload.data[t]!==void 0,n={data:A((_=a.payload.data[t])!=null?_:e.default()),pending:c(!u()),error:c((w=a.payload._errors[t])!=null?w:null)};n.refresh=(o={})=>a._asyncDataPromises[t]?a._asyncDataPromises[t]:o._initial&&u()?a.payload.data[t]:(n.pending.value=!0,a._asyncDataPromises[t]=new Promise((r,C)=>{try{r(f(a))}catch(x){C(x)}}).then(r=>{e.transform&&(r=e.transform(r)),e.pick&&(r=E(r,e.pick)),n.data.value=r,n.error.value=null}).catch(r=>{n.error.value=r,n.data.value=R(e.default())}).finally(()=>{n.pending.value=!1,a.payload.data[t]=n.data.value,n.error.value&&(a.payload._errors[t]=!0),delete a._asyncDataPromises[t]}),a._asyncDataPromises[t]);const d=()=>n.refresh({_initial:!0}),b=e.server!==!1&&a.payload.serverRendered;{b&&a.isHydrating&&t in a.payload.data?n.pending.value=!1:i&&a.payload.serverRendered&&(a.isHydrating||e.lazy)?i._nuxtOnBeforeMountCbs.push(d):d(),e.watch&&z(e.watch,()=>n.refresh());const o=a.hook("app:data:refresh",r=>{if(!r||r.includes(t))return n.refresh()});i&&g(o)}const y=Promise.resolve(a._asyncDataPromises[t]).then(()=>n);return Object.assign(y,n),y}function E(s,l){const t={};for(const f of l)t[f]=s[f];return t}export{j as u};
